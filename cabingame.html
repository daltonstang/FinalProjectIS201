<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Cabin 12: The Last Switch</title>
  <style>
    /* =========================================================
       CABIN 12: THE LAST SWITCH
       Single-file game (HTML + CSS + JS)
       Controls:
         - Move: WASD / Arrow keys
         - Sprint: Shift
         - Interact: Left-click (near objects) or E
         - Map overlay: M
         - Pause: P
       ========================================================= */

    :root{
      /* ===== THEME / COLORS (mountain + spooky) ===== */
      --bg0:#0b0f10;
      --bg1:#0e1413;
      --fog:#0b0f10;
      --ink:#e7efe9;
      --muted:#b8c6bc;
      --panel:#0f1514cc;
      --panel2:#0d1211e6;
      --accent:#b9d7c8;
      --danger:#e6a7a7;
      --gold:#e9d7a6;
      --wood:#2a1f17;
      --stone:#1a2422;
      --pine:#13211c;
      --lamp:#ffd9a3;
      --wire:#9aa7a0;
      --ok:#b9f2c2;
    }

    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(1200px 700px at 50% 40%, #121a18 0%, var(--bg0) 55%, #070a0b 100%);
      color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow:hidden;
    }

    .wrap{
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
    }

    .frame{
      width:min(1100px, 96vw);
      height:min(700px, 88vh);
      border-radius:20px;
      position:relative;
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.06);
      background:
        radial-gradient(900px 520px at 60% 25%, rgba(185,215,200,.06), transparent 60%),
        radial-gradient(600px 360px at 20% 70%, rgba(255,217,163,.05), transparent 70%),
        linear-gradient(180deg, rgba(15,21,20,.92), rgba(10,14,14,.92));
      overflow:hidden;
    }

    canvas{
      width:100%;
      height:100%;
      display:block;
      image-rendering: pixelated;
      cursor: crosshair;
    }

    /* ===== UI PANELS ===== */
    .hud{
      position:absolute;
      inset:0;
      pointer-events:none;
    }

    .topbar{
      position:absolute;
      top:14px;
      left:14px;
      right:14px;
      display:flex;
      gap:12px;
      align-items:flex-start;
      justify-content:space-between;
      pointer-events:none;
    }

    .pill{
      pointer-events:none;
      background: var(--panel);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:10px 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
      max-width: 420px;
    }

    .pill h1{
      margin:0;
      font-size:14px;
      letter-spacing:.08em;
      font-weight:800;
      text-transform:uppercase;
      color: var(--accent);
    }
    .pill .sub{
      margin-top:6px;
      font-size:12px;
      color: var(--muted);
      line-height:1.3;
    }

    .rightstack{
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:flex-end;
    }

    .meterRow{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
    }

    .meter{
      width:150px;
      height:10px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .meter > i{
      display:block;
      height:100%;
      width:50%;
      background: linear-gradient(90deg, rgba(255,217,163,.25), rgba(255,217,163,.85));
      border-radius:999px;
    }
    .meterLabel{
      font-size:12px;
      color: var(--muted);
      letter-spacing:.02em;
    }

    .dialogue{
      position:absolute;
      left:14px;
      bottom:14px;
      width:min(560px, calc(100% - 28px));
      pointer-events:none;
      background: var(--panel2);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:12px 14px;
      backdrop-filter: blur(10px);
      box-shadow: 0 12px 30px rgba(0,0,0,.45);
    }

    .dialogue .name{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin:0 0 6px 0;
      font-size:12px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color: var(--accent);
      font-weight:800;
    }

    .dialogue .line{
      margin:0;
      font-size:13px;
      color: var(--ink);
      line-height:1.35;
    }

    .dialogue .hint{
      margin-top:8px;
      font-size:12px;
      color: var(--muted);
      display:flex;
      justify-content:space-between;
      gap:10px;
    }

    .centerCard{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
    }

    .modal{
      width:min(720px, calc(100% - 34px));
      background: rgba(10,14,14,.92);
      border:1px solid rgba(255,255,255,.10);
      border-radius:18px;
      padding:18px 18px 16px;
      box-shadow: 0 22px 70px rgba(0,0,0,.65);
      backdrop-filter: blur(12px);
      pointer-events:auto;
    }

    .modal h2{
      margin:0 0 8px 0;
      font-size:18px;
      letter-spacing:.06em;
      text-transform:uppercase;
      color: var(--accent);
    }
    .modal p{
      margin:8px 0;
      color: var(--muted);
      line-height:1.4;
      font-size:13px;
    }
    .kbd{
      display:inline-block;
      padding:2px 8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--ink);
      font-size:12px;
      letter-spacing:.02em;
      margin:0 2px;
    }
    .btnRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:12px;
    }
    button{
      pointer-events:auto;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(185,215,200,.10);
      color: var(--ink);
      border-radius:14px;
      padding:10px 12px;
      font-weight:800;
      letter-spacing:.04em;
      cursor:pointer;
      transition: transform .08s ease, background .15s ease, border-color .15s ease;
    }
    button:hover{ transform: translateY(-1px); background: rgba(185,215,200,.16); border-color: rgba(255,255,255,.20); }
    button:active{ transform: translateY(0px); }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:12px;
      color: var(--muted);
      margin-top:8px;
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background: rgba(255,217,163,.85);
      box-shadow: 0 0 14px rgba(255,217,163,.55);
    }

    .mapPanel{
      position:absolute;
      top:70px;
      right:14px;
      width:min(260px, 38vw);
      pointer-events:none;
      background: var(--panel2);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:10px 10px 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 12px 30px rgba(0,0,0,.45);
      opacity:0;
      transform: translateY(-6px);
      transition: opacity .18s ease, transform .18s ease;
    }
    .mapPanel.on{ opacity:1; transform: translateY(0px); }

    .mapPanel .title{
      display:flex; align-items:center; justify-content:space-between;
      font-size:12px; letter-spacing:.10em; text-transform:uppercase;
      color: var(--accent); font-weight:800; margin:2px 2px 8px;
    }
    .mapPanel .mini{
      width:100%;
      aspect-ratio: 1 / 1;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:12px;
      color: var(--muted);
      position:relative;
    }
    .mapPanel .legend{
      margin-top:8px;
      font-size:12px;
      color: var(--muted);
      line-height:1.35;
    }

    .toast{
      position:absolute;
      top:14px;
      left:50%;
      transform: translateX(-50%);
      background: rgba(10,14,14,.92);
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;
      padding:8px 12px;
      font-size:12px;
      color: var(--ink);
      pointer-events:none;
      opacity:0;
      transition: opacity .18s ease, transform .18s ease;
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
    }
    .toast.on{
      opacity:1;
      transform: translateX(-50%) translateY(2px);
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="frame">
    <canvas id="game" width="1100" height="700"></canvas>

    <div class="hud">
      <div class="toast" id="toast">…</div>

      <div class="topbar">
        <div class="pill" id="objectiveBox">
          <h1>Objective</h1>
          <div class="sub" id="objectiveText">Find your bearings.</div>
        </div>

        <div class="rightstack">
          <div class="pill" style="max-width:420px;">
            <h1>Cabin 12</h1>
            <div class="sub">
              Move: <span class="kbd">WASD</span>
              Interact: <span class="kbd">Click</span>/<span class="kbd">E</span>
              Map: <span class="kbd">M</span>
              Pause: <span class="kbd">P</span>
            </div>
          </div>

          <div class="pill">
            <div class="meterRow">
              <span class="meterLabel">Trust</span>
              <span class="meter"><i id="trustBar"></i></span>
            </div>
            <div class="meterRow" style="margin-top:8px;">
              <span class="meterLabel">Dawn</span>
              <span class="meter"><i id="dawnBar"></i></span>
            </div>
          </div>
        </div>
      </div>

      <div class="mapPanel" id="mapPanel">
        <div class="title">
          <span>Field Map</span>
          <span style="color:var(--muted); letter-spacing:.02em; text-transform:none;">(M)</span>
        </div>
        <div class="mini" id="miniMap">
          <canvas id="mini" width="220" height="220" style="width:92%; height:92%; border-radius:12px;"></canvas>
        </div>
        <div class="legend">
          • Your position is the pale dot.<br/>
          • Doors shift with switches.<br/>
          • The map updates as you explore.
        </div>
      </div>

      <div class="dialogue" id="dialogueBox">
        <div class="name">
          <span>COMPANION: <span id="companionName">PINE</span></span>
          <span style="color:var(--muted); letter-spacing:.02em; text-transform:none;" id="moodLabel">mood: watchful</span>
        </div>
        <p class="line" id="dialogueLine">…</p>
        <div class="hint">
          <span id="hintLeft">Tip: click near a switch to interact.</span>
          <span id="hintRight">Press M for map.</span>
        </div>
      </div>

      <div class="centerCard" id="startModal">
        <div class="modal">
          <h2>Cabin 12: The Last Switch</h2>
          <p>
            You wake to pine shadows and a cabin that refuses to stay the same.
            Switches don’t just turn lights on. They rearrange doors, walls, and the way out.
          </p>
          <p>
            <strong>Your goal:</strong> restore power, open the exit, and escape before dawn fills the windows.
          </p>
          <p>
            Controls: <span class="kbd">WASD</span> move, <span class="kbd">Shift</span> sprint,
            <span class="kbd">Click</span> / <span class="kbd">E</span> interact,
            <span class="kbd">M</span> map, <span class="kbd">P</span> pause.
          </p>
          <div class="btnRow">
            <button id="btnStart">Start</button>
            <button id="btnChill">Chill Mode (slower dawn)</button>
            <button id="btnHard">Spooky Mode (faster dawn)</button>
          </div>
          <div class="badge"><span class="dot"></span><span>Tip: Stand near a switch, then click it. Watch what changes.</span></div>
        </div>
      </div>

      <div class="centerCard" id="endModal" style="display:none;">
        <div class="modal">
          <h2 id="endTitle">…</h2>
          <p id="endText">…</p>
          <div class="btnRow">
            <button id="btnRestart">Restart</button>
          </div>
          <div class="badge"><span class="dot"></span><span id="endHint">Try a different switch order next run.</span></div>
        </div>
      </div>

      <div class="centerCard" id="pauseModal" style="display:none;">
        <div class="modal">
          <h2>Paused</h2>
          <p>Press <span class="kbd">P</span> to resume.</p>
          <div class="btnRow">
            <button id="btnResume">Resume</button>
            <button id="btnRestart2">Restart</button>
          </div>
        </div>
      </div>

    </div>
  </div>
</div>

<script>
/* =========================================================
   GAME SETTINGS (easy tweak zone)
   ========================================================= */
const CONFIG = {
  tile: 40,           // world grid tile size (px)
  playerRadius: 12,
  interactRange: 44,
  baseSpeed: 160,     // px/sec
  sprintMult: 1.55,
  dawnSeconds: 240,   // time until "dawn" (lose) in normal mode
  chillDawnSeconds: 360,
  hardDawnSeconds: 165,
  cameraLerp: 0.10,
  shakeMax: 6,
  fogAlphaBase: 0.86,  // overall darkness
  lightRadius: 150,    // player lantern radius
  lightSoftness: 0.55,
  ambientInsideBoost: 0.12,
  showDebug: false
};

/* =========================================================
   CANVAS + CONTEXT
   ========================================================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const miniCanvas = document.getElementById("mini");
const mctx = miniCanvas.getContext("2d");

/* =========================================================
   UI HOOKS
   ========================================================= */
const objectiveText = document.getElementById("objectiveText");
const dialogueLine = document.getElementById("dialogueLine");
const moodLabel = document.getElementById("moodLabel");
const trustBar = document.getElementById("trustBar");
const dawnBar = document.getElementById("dawnBar");
const toast = document.getElementById("toast");
const mapPanel = document.getElementById("mapPanel");

const startModal = document.getElementById("startModal");
const endModal = document.getElementById("endModal");
const pauseModal = document.getElementById("pauseModal");
const endTitle = document.getElementById("endTitle");
const endText = document.getElementById("endText");
const endHint = document.getElementById("endHint");

document.getElementById("btnStart").onclick = () => startGame("normal");
document.getElementById("btnChill").onclick = () => startGame("chill");
document.getElementById("btnHard").onclick = () => startGame("hard");
document.getElementById("btnRestart").onclick = () => location.reload();
document.getElementById("btnRestart2").onclick = () => location.reload();
document.getElementById("btnResume").onclick = () => togglePause(false);

/* =========================================================
   INPUT
   ========================================================= */
const keys = new Set();
let mouse = {x:0, y:0, down:false, clicked:false};

window.addEventListener("keydown", (e)=>{
  if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
  keys.add(e.key.toLowerCase());
  if(e.key.toLowerCase()==="p" && state.started && !state.ended) togglePause();
  if(e.key.toLowerCase()==="m" && state.started && !state.ended) toggleMap();
  if(e.key.toLowerCase()==="e" && state.started && !state.ended && !state.paused) interactNearest();
});

window.addEventListener("keyup", (e)=> keys.delete(e.key.toLowerCase()));

canvas.addEventListener("mousemove", (e)=>{
  const r = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
  mouse.y = (e.clientY - r.top) * (canvas.height / r.height);
});

canvas.addEventListener("mousedown", (e)=>{
  mouse.down = true;
  mouse.clicked = true;
});

window.addEventListener("mouseup", ()=>{
  mouse.down = false;
});

/* =========================================================
   WORLD / LEVEL DATA (editable + clear)
   ========================================================= */
/*
  We use a simple rectangle-based world.
  "solids" are walls/rocks/trees you cannot pass.
  Doors are rectangles that can toggle open/closed.
  Switches toggle a global boolean and can change doors/walls.

  V1 OBJECTIVES:
   1) Find the Fuse (pickup).
   2) Install Fuse (in breaker).
   3) Power Exit (flip exit switch).
   4) Escape through the front gate.
*/

function rect(x,y,w,h){ return {x,y,w,h}; }
function pointInRect(px,py,r){ return px>=r.x && px<=r.x+r.w && py>=r.y && py<=r.y+r.h; }
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

const WORLD = {
  w: 1800,
  h: 1200,

  // static solids (won't change)
  solids: [
    // outer "woods" edges
    rect(0,0,1800,60),
    rect(0,1140,1800,60),
    rect(0,0,60,1200),
    rect(1740,0,60,1200),

    // trees / rocks clusters outside (simple chunky shapes)
    rect(120,140,220,120),
    rect(280,360,160,170),
    rect(140,700,240,140),
    rect(520,820,220,160),
    rect(1220,140,240,140),
    rect(1440,360,170,200),
    rect(1320,760,260,170),

    // cabin exterior block (shell wall thickness)
    rect(680,250,520,20),
    rect(680,250,20,420),
    rect(1180,250,20,420),
    rect(680,650,520,20),

    // interior fixed walls
    rect(930,250,20,300),      // center divider
    rect(680,400,250,20),      // left horizontal
    rect(950,520,250,20),      // right horizontal
  ],

  // dynamic walls (appear/disappear based on switches)
  dynWalls: [
    // wall that sometimes blocks hallway
    { id:"wallHall", r: rect(930,550,20,120), active:true },
    // wall that sometimes blocks left room
    { id:"wallLeft", r: rect(780,400,20,270), active:false }
  ],

  doors: [
    // cabin entrances / interior doors (toggle)
    { id:"frontDoor", r: rect(920,650,40,20), open:false, kind:"door", label:"Front Door" },
    { id:"leftDoor",  r: rect(680,520,20,50), open:true,  kind:"door", label:"Mudroom Door" },
    { id:"rightDoor", r: rect(1180,360,20,60), open:false, kind:"door", label:"Study Door" },
    { id:"hallDoor",  r: rect(930,400,20,60), open:true,  kind:"door", label:"Hall Door" },

    // outside gate (final exit)
    { id:"exitGate",  r: rect(1680,560,60,80), open:false, kind:"gate", label:"Ridge Gate" }
  ],

  // interactable objects
  objects: [
    { id:"switchA", kind:"switch", label:"Switch A", pos:{x:760,y:330}, state:false },
    { id:"switchB", kind:"switch", label:"Switch B", pos:{x:1120,y:610}, state:false },
    { id:"breaker", kind:"breaker", label:"Breaker Box", pos:{x:1060,y:330}, powered:false },
    { id:"fuse", kind:"pickup", label:"Fuse", pos:{x:820,y:610}, taken:false },
    { id:"exitSwitch", kind:"switch", label:"Exit Switch", pos:{x:1620,y:600}, state:false, locked:true }
  ],

  // zones to trigger story or ambience
  zones: [
    { id:"insideCabin", r: rect(700,270,480,380) }
  ]
};

/* =========================================================
   GAME STATE
   ========================================================= */
const state = {
  started:false,
  paused:false,
  ended:false,
  mode:"normal",

  t:0,
  dt:0,
  last:0,

  dawnT:0,           // counts up to dawnSeconds
  dawnSeconds: CONFIG.dawnSeconds,

  // player + camera
  player: { x: 860, y: 980, vx:0, vy:0, facing:{x:1,y:0} },
  cam: { x: 0, y: 0 },
  shake: 0,

  // objectives
  objectiveIndex: 0,
  objectives: [
    { id:"findFuse", text:"Find the fuse inside Cabin 12.", done:false },
    { id:"installFuse", text:"Install the fuse in the breaker box.", done:false },
    { id:"powerExit", text:"Find the exit switch and power the ridge gate.", done:false },
    { id:"escape", text:"Escape through the ridge gate before dawn.", done:false }
  ],

  // companion AI
  companion: {
    name:"PINE",
    trust: 0.62,            // 0..1
    mood: "watchful",       // watchful, calm, uneasy, helpful
    lastSpokeAt: -999,
    memory: [],             // recent observations
    misleadChance: 0.18
  },

  // map
  mapOn:false,
  explored: new Set(),      // explored mini-tiles
};

/* =========================================================
   HELPERS: UI
   ========================================================= */
function setObjectiveText(){
  const current = state.objectives[state.objectiveIndex];
  objectiveText.textContent = current ? current.text : "…";
}
function setDialogue(text, mood=null){
  dialogueLine.textContent = text;
  if(mood) state.companion.mood = mood;
  moodLabel.textContent = `mood: ${state.companion.mood}`;
  state.companion.lastSpokeAt = state.t;
}
let toastTimer = 0;
function showToast(msg, seconds=1.2){
  toast.textContent = msg;
  toast.classList.add("on");
  toastTimer = seconds;
}

/* =========================================================
   START / END / PAUSE
   ========================================================= */
function startGame(mode){
  state.mode = mode;
  state.started = true;
  startModal.style.display = "none";

  state.dawnSeconds = (mode==="chill") ? CONFIG.chillDawnSeconds
                    : (mode==="hard") ? CONFIG.hardDawnSeconds
                    : CONFIG.dawnSeconds;

  setObjectiveText();
  setDialogue("You’re awake. Cold wood. Pine resin. The cabin breathes like it’s listening.", "watchful");
  showToast("Find a switch. Watch what changes.", 1.6);

  requestAnimationFrame(loop);
}

function endGame(win){
  state.ended = true;
  endModal.style.display = "flex";
  if(win){
    endTitle.textContent = "You slipped out.";
    endText.textContent = "The ridge wind bites, but it’s honest. Behind you, Cabin 12 forgets you existed.";
    endHint.textContent = "Want it spookier? Ask me to add footsteps, whispers, or a roaming shadow.";
  } else {
    endTitle.textContent = "Dawn found you.";
    endText.textContent = "Light crawls into the cabin’s corners. The switches stop obeying. The door won’t remember your hands.";
    endHint.textContent = "Try switching slower and watching which doors move with each flip.";
  }
}

function togglePause(force){
  if(state.ended || !state.started) return;
  state.paused = (typeof force==="boolean") ? force : !state.paused;
  pauseModal.style.display = state.paused ? "flex" : "none";
}
function toggleMap(){
  state.mapOn = !state.mapOn;
  mapPanel.classList.toggle("on", state.mapOn);
}

/* =========================================================
   COLLISION
   ========================================================= */
function circleRectCollide(cx,cy,cr, r){
  const nx = clamp(cx, r.x, r.x+r.w);
  const ny = clamp(cy, r.y, r.y+r.h);
  const dx = cx - nx;
  const dy = cy - ny;
  return (dx*dx + dy*dy) < (cr*cr);
}

function isSolidRect(r){
  // includes static solids, active dyn walls, closed doors, and gate if closed
  // called during collision sampling
  return true;
}

function getAllSolids(){
  const arr = [];
  for(const s of WORLD.solids) arr.push(s);
  for(const w of WORLD.dynWalls) if(w.active) arr.push(w.r);
  for(const d of WORLD.doors){
    if(!d.open){
      arr.push(d.r);
    }
  }
  return arr;
}

function movePlayer(dt){
  const p = state.player;
  let ix = 0, iy = 0;
  if(keys.has("w") || keys.has("arrowup")) iy -= 1;
  if(keys.has("s") || keys.has("arrowdown")) iy += 1;
  if(keys.has("a") || keys.has("arrowleft")) ix -= 1;
  if(keys.has("d") || keys.has("arrowright")) ix += 1;

  const mag = Math.hypot(ix,iy) || 1;
  ix/=mag; iy/=mag;

  const sprint = keys.has("shift");
  const speed = CONFIG.baseSpeed * (sprint ? CONFIG.sprintMult : 1);

  const vx = ix * speed;
  const vy = iy * speed;

  if(Math.hypot(vx,vy) > 1){
    p.facing.x = ix; p.facing.y = iy;
  }

  // attempt axis moves separately for nicer collisions
  const solids = getAllSolids();
  let nx = p.x + vx*dt;
  let ny = p.y;

  for(const r of solids){
    if(circleRectCollide(nx, ny, CONFIG.playerRadius, r)){
      nx = p.x; break;
    }
  }
  p.x = nx;

  nx = p.x;
  ny = p.y + vy*dt;
  for(const r of solids){
    if(circleRectCollide(nx, ny, CONFIG.playerRadius, r)){
      ny = p.y; break;
    }
  }
  p.y = ny;

  // clamp to world bounds
  p.x = clamp(p.x, 80, WORLD.w-80);
  p.y = clamp(p.y, 80, WORLD.h-80);

  // explore map cells
  const cell = `${Math.floor(p.x/80)},${Math.floor(p.y/80)}`;
  state.explored.add(cell);
}

/* =========================================================
   INTERACTION
   ========================================================= */
function nearestInteractable(){
  const p = state.player;
  let best = null;
  let bestD = Infinity;

  // objects
  for(const o of WORLD.objects){
    if(o.kind==="pickup" && o.taken) continue;
    if(o.id==="exitSwitch" && o.locked) {
      // still interactable, but will say locked
    }
    const d = Math.hypot(p.x-o.pos.x, p.y-o.pos.y);
    if(d < bestD){
      bestD = d;
      best = {type:"object", ref:o, d};
    }
  }

  // doors (for "open/close" feel, but we won't toggle them manually in v1)
  for(const d0 of WORLD.doors){
    const cx = d0.r.x + d0.r.w/2;
    const cy = d0.r.y + d0.r.h/2;
    const d = Math.hypot(p.x-cx, p.y-cy);
    if(d < bestD){
      bestD = d;
      best = {type:"door", ref:d0, d};
    }
  }

  return best;
}

function interactNearest(){
  const hit = nearestInteractable();
  if(!hit || hit.d > CONFIG.interactRange) return;

  if(hit.type==="object"){
    const o = hit.ref;

    if(o.kind==="pickup"){
      o.taken = true;
      showToast("Picked up: Fuse", 1.2);
      observe(`You found the fuse.`);
      state.objectives[0].done = true;
      if(state.objectiveIndex===0) state.objectiveIndex = 1;
      setObjectiveText();
      companionSpeakContextual("pickup_fuse");
      return;
    }

    if(o.kind==="breaker"){
      if(!state.objectives[0].done){
        showToast("Breaker box needs a fuse.", 1.2);
        companionSpeakContextual("breaker_no_fuse");
        return;
      }
      if(!o.powered){
        o.powered = true;
        showToast("Power restored.", 1.2);
        observe("Breaker is powered.");
        state.objectives[1].done = true;
        if(state.objectiveIndex===1) state.objectiveIndex = 2;
        setObjectiveText();
        companionSpeakContextual("breaker_powered");
        applyWorldRules(); // breaker may unlock behaviors
      } else {
        showToast("Already powered.", 0.9);
      }
      return;
    }

    if(o.kind==="switch"){
      if(o.id==="exitSwitch"){
        if(o.locked){
          showToast("Exit switch is dead. Needs power.", 1.2);
          companionSpeakContextual("exit_locked");
          state.companion.trust = clamp(state.companion.trust - 0.02, 0, 1);
          return;
        }
        o.state = !o.state;
        showToast(o.state ? "Exit switch ON" : "Exit switch OFF", 1.0);
        observe(`Exit switch ${o.state ? "ON" : "OFF"}.`);
        if(o.state){
          // open exit gate
          const gate = WORLD.doors.find(d=>d.id==="exitGate");
          gate.open = true;
          state.objectives[2].done = true;
          if(state.objectiveIndex===2) state.objectiveIndex = 3;
          setObjectiveText();
          companionSpeakContextual("exit_powered");
        } else {
          // close gate if switched off (keeps tension)
          const gate = WORLD.doors.find(d=>d.id==="exitGate");
          gate.open = false;
        }
        return;
      }

      // Switch A / B
      o.state = !o.state;
      showToast(`${o.label} ${o.state ? "ON" : "OFF"}`, 1.0);
      observe(`${o.label} toggled.`);
      applyWorldRules();
      companionSpeakContextual(o.id);
      return;
    }
  }

  if(hit.type==="door"){
    // v1: doors are controlled by switches; clicking doors gives info
    showToast(`${hit.ref.label}: ${hit.ref.open ? "open" : "closed"}`, 1.0);
    companionSpeakContextual("door_info");
  }
}

canvas.addEventListener("click", ()=>{
  if(!state.started || state.paused || state.ended) return;
  interactNearest();
});

/* =========================================================
   WORLD RULES (switch logic)
   ========================================================= */
function applyWorldRules(){
  const sA = WORLD.objects.find(o=>o.id==="switchA").state;
  const sB = WORLD.objects.find(o=>o.id==="switchB").state;
  const breaker = WORLD.objects.find(o=>o.id==="breaker").powered;

  // Door mapping: (designed for learnable patterns)
  // - Switch A: controls the front door + hall door pairing
  // - Switch B: controls the study door + mudroom door
  // - When BOTH are ON: hallway wall appears (forces alternate route)
  // - When BOTH are OFF: left wall appears (forces central route)
  const frontDoor = WORLD.doors.find(d=>d.id==="frontDoor");
  const hallDoor  = WORLD.doors.find(d=>d.id==="hallDoor");
  const rightDoor = WORLD.doors.find(d=>d.id==="rightDoor");
  const leftDoor  = WORLD.doors.find(d=>d.id==="leftDoor");

  // A toggles front/hall
  frontDoor.open = sA;      // ON opens front door (but gate still locked)
  hallDoor.open  = !sA;     // ON closes hall door (pushes you around)

  // B toggles right/left
  rightDoor.open = sB;
  leftDoor.open  = !sB;

  // Dynamic walls
  const wallHall = WORLD.dynWalls.find(w=>w.id==="wallHall");
  const wallLeft = WORLD.dynWalls.find(w=>w.id==="wallLeft");

  wallHall.active = (sA && sB);    // both on -> hallway blocked
  wallLeft.active = (!sA && !sB);  // both off -> left route blocked

  // Exit switch unlocks only if breaker powered
  const exitSwitch = WORLD.objects.find(o=>o.id==="exitSwitch");
  exitSwitch.locked = !breaker;

  // If breaker powered, also slightly brighten inside (feels rewarding)
}

/* =========================================================
   COMPANION AI: tiny but fun
   ========================================================= */
function observe(note){
  // store small memory list
  state.companion.memory.push({t:state.t, note});
  if(state.companion.memory.length > 6) state.companion.memory.shift();
}

function companionSpeakContextual(trigger){
  const c = state.companion;
  // mood shifts based on dawn + trust
  const dawnP = state.dawnT / state.dawnSeconds;
  if(dawnP > 0.75) c.mood = (c.trust > 0.55) ? "helpful" : "uneasy";
  else if(dawnP > 0.45) c.mood = (c.trust > 0.50) ? "watchful" : "uneasy";
  else c.mood = (c.trust > 0.60) ? "calm" : "watchful";

  // avoid spamming
  if(state.t - c.lastSpokeAt < 1.2) return;

  // sometimes mislead if low trust or spooky mode
  const extraMislead = (state.mode==="hard") ? 0.06 : 0;
  const mislead = Math.random() < (c.misleadChance + extraMislead) * (1 - c.trust + 0.15);

  const sA = WORLD.objects.find(o=>o.id==="switchA").state;
  const sB = WORLD.objects.find(o=>o.id==="switchB").state;
  const breaker = WORLD.objects.find(o=>o.id==="breaker").powered;

  const lines = {
    intro: [
      "If you hear the cabin… ignore it. Focus on what changes when you flip a switch.",
      "Two switches. One cabin. Too many lies. Let’s make the cabin repeat itself."
    ],
    switchA: [
      `Switch A… it feels tied to the front. Doors trade places when it flips.`,
      `A toggled. Watch the front door and the hall. They don’t like being open at the same time.`
    ],
    switchB: [
      `Switch B likes the side rooms. Study and mudroom, like a breath in… breath out.`,
      `B moved something. Right side, left side. Keep an eye on the corners.`
    ],
    pickup_fuse: [
      "Good. A fuse means the cabin might finally obey physics for a minute.",
      "Careful holding that. Metal remembers heat."
    ],
    breaker_no_fuse: [
      "Breaker’s hungry. It wants something small, sharp, and important. A fuse.",
      "No fuse, no power. No power, no exit. Simple… in theory."
    ],
    breaker_powered: [
      "There. The hum is back. The cabin’s… less playful now.",
      "Power restored. Now the exit switch should wake up outside."
    ],
    exit_locked: [
      "Dead switch. We need power first. Find the breaker inside.",
      "It won’t click until the cabin is fed electricity."
    ],
    exit_powered: [
      "Gate should be open. Don’t hesitate. The mountain likes to change its mind.",
      "That’s it. Go. Before the light gets curious."
    ],
    door_info: [
      "Doors are symptoms, not solutions. The switches are the cause.",
      "If a door is closed, ask: which switch is trying to hide you?"
    ]
  };

  let pool = [];
  if(trigger==="switchA") pool = lines.switchA;
  else if(trigger==="switchB") pool = lines.switchB;
  else if(trigger==="pickup_fuse") pool = lines.pickup_fuse;
  else if(trigger==="breaker_no_fuse") pool = lines.breaker_no_fuse;
  else if(trigger==="breaker_powered") pool = lines.breaker_powered;
  else if(trigger==="exit_locked") pool = lines.exit_locked;
  else if(trigger==="exit_powered") pool = lines.exit_powered;
  else if(trigger==="door_info") pool = lines.door_info;
  else pool = lines.intro;

  let line = pool[Math.floor(Math.random()*pool.length)];

  // a gentle "hint engine"
  if(!breaker && (state.objectiveIndex===2 || state.objectiveIndex===0)){
    // keep reminding about fuse/breaker
    if(Math.random()<0.35) line = "If the exit feels dead, remember: fuse first, breaker second.";
  }

  if(mislead){
    // subtle mislead: suggest wrong door focus
    const mis = [
      "I’m pretty sure Switch A controls the study door… unless I’m remembering a different cabin.",
      "Try leaving both switches OFF. I think that opens more doors. I think."
    ];
    line = mis[Math.floor(Math.random()*mis.length)];
    c.trust = clamp(c.trust - 0.03, 0, 1);
  } else {
    // reward trust slightly if player makes progress
    if(trigger==="pickup_fuse" || trigger==="breaker_powered" || trigger==="exit_powered"){
      c.trust = clamp(c.trust + 0.06, 0, 1);
    } else if(trigger==="switchA" || trigger==="switchB"){
      c.trust = clamp(c.trust + 0.01, 0, 1);
    }
  }

  setDialogue(line, c.mood);
}

/* =========================================================
   DRAWING
   ========================================================= */
function draw(){
  const p = state.player;

  // camera follows player
  const targetCamX = p.x - canvas.width/2;
  const targetCamY = p.y - canvas.height/2;
  state.cam.x += (targetCamX - state.cam.x) * CONFIG.cameraLerp;
  state.cam.y += (targetCamY - state.cam.y) * CONFIG.cameraLerp;

  // clamp camera to world
  state.cam.x = clamp(state.cam.x, 0, WORLD.w - canvas.width);
  state.cam.y = clamp(state.cam.y, 0, WORLD.h - canvas.height);

  // subtle shake as dawn approaches
  const dawnP = state.dawnT / state.dawnSeconds;
  const shakeAmt = CONFIG.shakeMax * Math.max(0, dawnP - 0.6) / 0.4;
  state.shake = Math.min(CONFIG.shakeMax, shakeAmt);

  const sx = (Math.random()*2-1) * state.shake;
  const sy = (Math.random()*2-1) * state.shake;

  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.save();
  ctx.translate(-state.cam.x + sx, -state.cam.y + sy);

  // background ground
  ctx.fillStyle = "#0a0f10";
  ctx.fillRect(0,0,WORLD.w,WORLD.h);

  // paint "pine" ground texture
  for(let y=0;y<WORLD.h;y+=80){
    for(let x=0;x<WORLD.w;x+=80){
      const v = (x*73856093 ^ y*19349663) & 255;
      ctx.fillStyle = `rgba(19,33,28,${0.06 + (v/255)*0.04})`;
      ctx.fillRect(x+8, y+10, 64, 56);
    }
  }

  // draw cabin interior floor area
  ctx.fillStyle = "rgba(42,31,23,0.85)";
  ctx.fillRect(700,270,480,380);

  // draw outside "ridge path" leading to gate
  ctx.fillStyle = "rgba(26,36,34,0.9)";
  ctx.fillRect(1180,530,520,140); // path strip
  ctx.fillRect(1540,400,160,270); // vertical to gate

  // draw solids (trees/rocks/cabin walls)
  drawRects(WORLD.solids, "rgba(26,36,34,1.0)", true);

  // dynamic walls
  for(const w of WORLD.dynWalls){
    if(!w.active) continue;
    ctx.fillStyle = "rgba(20,30,28,1.0)";
    ctx.fillRect(w.r.x, w.r.y, w.r.w, w.r.h);
  }

  // doors (closed doors drawn as planks, open doors as shadow gap)
  for(const d of WORLD.doors){
    if(d.open){
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(d.r.x, d.r.y, d.r.w, d.r.h);
    } else {
      const isGate = d.kind==="gate";
      ctx.fillStyle = isGate ? "rgba(18,28,26,1.0)" : "rgba(54,38,28,1.0)";
      ctx.fillRect(d.r.x, d.r.y, d.r.w, d.r.h);
      // little brace line
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(d.r.x + (d.r.w> d.r.h ? 6 : 2), d.r.y + (d.r.h> d.r.w ? 6 : 2), Math.max(6, d.r.w-12), 2);
    }
  }

  // objects
  for(const o of WORLD.objects){
    if(o.kind==="pickup" && o.taken) continue;

    if(o.kind==="switch"){
      // switch is a small plate + lever
      const on = !!o.state;
      // exit switch gray if locked
      const locked = (o.id==="exitSwitch" && o.locked);
      ctx.fillStyle = locked ? "rgba(154,167,160,0.25)" : "rgba(185,215,200,0.20)";
      ctx.fillRect(o.pos.x-10, o.pos.y-10, 20, 20);

      ctx.fillStyle = locked ? "rgba(154,167,160,0.35)" : (on ? "rgba(255,217,163,0.90)" : "rgba(255,255,255,0.12)");
      ctx.beginPath();
      ctx.roundRect(o.pos.x-3, o.pos.y-8, 6, 16, 3);
      ctx.fill();

      // tiny glow if on
      if(on && !locked){
        ctx.fillStyle = "rgba(255,217,163,0.12)";
        ctx.beginPath();
        ctx.arc(o.pos.x, o.pos.y, 20, 0, Math.PI*2);
        ctx.fill();
      }
    }

    if(o.kind==="breaker"){
      ctx.fillStyle = "rgba(154,167,160,0.20)";
      ctx.fillRect(o.pos.x-14, o.pos.y-12, 28, 24);
      ctx.fillStyle = o.powered ? "rgba(185,242,194,0.85)" : "rgba(230,167,167,0.55)";
      ctx.fillRect(o.pos.x-12, o.pos.y+8, 24, 3);
    }

    if(o.kind==="pickup"){
      // fuse
      ctx.fillStyle = "rgba(233,215,166,0.9)";
      ctx.fillRect(o.pos.x-9, o.pos.y-3, 18, 6);
      ctx.fillStyle = "rgba(0,0,0,0.28)";
      ctx.fillRect(o.pos.x-6, o.pos.y-1, 12, 2);
    }
  }

  // player
  ctx.fillStyle = "rgba(231,239,233,0.92)";
  ctx.beginPath();
  ctx.arc(p.x, p.y, CONFIG.playerRadius, 0, Math.PI*2);
  ctx.fill();

  // small "direction" notch
  ctx.fillStyle = "rgba(0,0,0,0.24)";
  ctx.beginPath();
  ctx.arc(p.x + p.facing.x*8, p.y + p.facing.y*8, 4, 0, Math.PI*2);
  ctx.fill();

  // interaction highlight
  const hit = nearestInteractable();
  if(hit && hit.d < CONFIG.interactRange){
    ctx.strokeStyle = "rgba(185,215,200,0.55)";
    ctx.lineWidth = 2;
    if(hit.type==="object"){
      ctx.beginPath();
      ctx.arc(hit.ref.pos.x, hit.ref.pos.y, 18, 0, Math.PI*2);
      ctx.stroke();
      drawWorldLabel(hit.ref.label, hit.ref.pos.x, hit.ref.pos.y - 22);
    } else {
      const d = hit.ref;
      ctx.strokeRect(d.r.x-2, d.r.y-2, d.r.w+4, d.r.h+4);
      drawWorldLabel(d.label, d.r.x + d.r.w/2, d.r.y - 10);
    }
  }

  // check win: reach gate area when open
  const gate = WORLD.doors.find(d=>d.id==="exitGate");
  if(gate.open && pointInRect(p.x, p.y, gate.r)){
    state.objectives[3].done = true;
    endGame(true);
  }

  ctx.restore();

  // lighting + fog overlay (screen space)
  drawFogAndLight();

  // debug
  if(CONFIG.showDebug){
    ctx.fillStyle="white";
    ctx.fillText(`p: ${Math.round(p.x)},${Math.round(p.y)}`, 14, canvas.height-10);
  }

  // mini-map
  drawMiniMap();
}

function drawRects(list, fillStyle, bevel=false){
  for(const r of list){
    ctx.fillStyle = fillStyle;
    ctx.fillRect(r.x, r.y, r.w, r.h);
    if(bevel){
      ctx.fillStyle = "rgba(255,255,255,0.05)";
      ctx.fillRect(r.x, r.y, r.w, 3);
      ctx.fillRect(r.x, r.y, 3, r.h);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(r.x, r.y+r.h-3, r.w, 3);
      ctx.fillRect(r.x+r.w-3, r.y, 3, r.h);
    }
  }
}

function drawWorldLabel(text, x, y){
  ctx.save();
  ctx.font = "12px ui-sans-serif, system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  const padX = 8, padY = 5;
  const w = ctx.measureText(text).width + padX*2;
  const h = 18 + padY;
  ctx.fillStyle = "rgba(10,14,14,0.75)";
  roundRect(ctx, x - w/2, y - h/2, w, h, 10);
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.stroke();
  ctx.fillStyle = "rgba(231,239,233,0.92)";
  ctx.fillText(text, x, y+1);
  ctx.restore();
}

function roundRect(c, x, y, w, h, r){
  c.beginPath();
  c.moveTo(x+r, y);
  c.arcTo(x+w, y, x+w, y+h, r);
  c.arcTo(x+w, y+h, x, y+h, r);
  c.arcTo(x, y+h, x, y, r);
  c.arcTo(x, y, x+w, y, r);
  c.closePath();
}

function drawFogAndLight(){
  const p = state.player;

  // base fog
  ctx.save();
  ctx.fillStyle = `rgba(11,15,16,${CONFIG.fogAlphaBase})`;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // carve lantern light using destination-out
  ctx.globalCompositeOperation = "destination-out";

  // convert player world to screen
  const px = p.x - state.cam.x;
  const py = p.y - state.cam.y;

  const inside = isInsideCabin(p.x, p.y);
  const breakerPowered = WORLD.objects.find(o=>o.id==="breaker").powered;
  const insideBoost = (inside && breakerPowered) ? CONFIG.ambientInsideBoost : 0;

  const radius = CONFIG.lightRadius + insideBoost*220;
  const grad = ctx.createRadialGradient(px, py, radius*0.10, px, py, radius);
  grad.addColorStop(0, `rgba(0,0,0,${0.95})`);
  grad.addColorStop(CONFIG.lightSoftness, `rgba(0,0,0,${0.25})`);
  grad.addColorStop(1, `rgba(0,0,0,0)`);

  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(px, py, radius, 0, Math.PI*2);
  ctx.fill();

  // faint "lamp flicker" if breaker powered
  if(breakerPowered && inside){
    const flick = 0.06 + 0.03*Math.sin(state.t*7.0);
    const g2 = ctx.createRadialGradient(px, py, radius*0.05, px, py, radius*0.70);
    g2.addColorStop(0, `rgba(0,0,0,${0.38 - flick})`);
    g2.addColorStop(1, `rgba(0,0,0,0)`);
    ctx.fillStyle = g2;
    ctx.beginPath();
    ctx.arc(px, py, radius*0.70, 0, Math.PI*2);
    ctx.fill();
  }

  // restore
  ctx.globalCompositeOperation = "source-over";

  // vignette (adds spooky)
  const vig = ctx.createRadialGradient(canvas.width/2, canvas.height/2, Math.min(canvas.width,canvas.height)*0.25,
                                       canvas.width/2, canvas.height/2, Math.max(canvas.width,canvas.height)*0.70);
  vig.addColorStop(0, "rgba(0,0,0,0)");
  vig.addColorStop(1, "rgba(0,0,0,0.55)");
  ctx.fillStyle = vig;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.restore();
}

function isInsideCabin(x,y){
  const z = WORLD.zones.find(z=>z.id==="insideCabin");
  return pointInRect(x,y,z.r);
}

/* =========================================================
   MINI MAP (simple + useful)
   ========================================================= */
function drawMiniMap(){
  if(!state.mapOn) return;

  const scale = 220 / 1800; // world to minimap
  mctx.setTransform(1,0,0,1,0,0);
  mctx.clearRect(0,0,miniCanvas.width, miniCanvas.height);

  // background
  mctx.fillStyle = "rgba(255,255,255,0.03)";
  mctx.fillRect(0,0,miniCanvas.width, miniCanvas.height);

  // explored cells
  for(const key of state.explored){
    const [cx,cy] = key.split(",").map(Number);
    const x = cx*80*scale;
    const y = cy*80*scale;
    mctx.fillStyle = "rgba(185,215,200,0.12)";
    mctx.fillRect(x, y, 80*scale, 80*scale);
  }

  // cabin outline
  mctx.strokeStyle = "rgba(255,217,163,0.35)";
  mctx.lineWidth = 2;
  mctx.strokeRect(680*scale, 250*scale, 520*scale, 420*scale);

  // player
  const p = state.player;
  mctx.fillStyle = "rgba(231,239,233,0.9)";
  mctx.beginPath();
  mctx.arc(p.x*scale, p.y*scale, 4, 0, Math.PI*2);
  mctx.fill();

  // gate marker if powered
  const gate = WORLD.doors.find(d=>d.id==="exitGate");
  mctx.fillStyle = gate.open ? "rgba(185,242,194,0.7)" : "rgba(230,167,167,0.45)";
  mctx.fillRect(gate.r.x*scale, gate.r.y*scale, gate.r.w*scale, gate.r.h*scale);
}

/* =========================================================
   GAME LOOP
   ========================================================= */
function loop(ts){
  if(!state.started) return;

  if(!state.last) state.last = ts;
  const rawDt = (ts - state.last) / 1000;
  state.last = ts;

  // cap dt (avoid huge jumps)
  state.dt = Math.min(0.033, rawDt);
  if(!state.paused && !state.ended){
    update(state.dt);
  }
  draw();

  requestAnimationFrame(loop);
}

function update(dt){
  state.t += dt;

  // toast timer
  if(toastTimer > 0){
    toastTimer -= dt;
    if(toastTimer <= 0) toast.classList.remove("on");
  }

  // dawn progress (lose condition)
  state.dawnT += dt;
  if(state.dawnT >= state.dawnSeconds){
    endGame(false);
  }

  // update UI bars
  trustBar.style.width = `${Math.round(state.companion.trust*100)}%`;
  const dawnP = clamp(state.dawnT / state.dawnSeconds, 0, 1);
  dawnBar.style.width = `${Math.round(dawnP*100)}%`;

  // move player
  movePlayer(dt);

  // gentle ambient companion reminders
  if(state.t - state.companion.lastSpokeAt > 12){
    const idx = state.objectiveIndex;
    if(idx===0){
      setDialogue("Start inside. Switches change doors. Find something that looks… important.", "watchful");
    } else if(idx===1){
      setDialogue("Breaker box. It should be on a wall, somewhere central. Don’t overthink it.", "calm");
    } else if(idx===2){
      setDialogue("Exit switch is outside. The ridge gate won’t open without it.", "helpful");
    } else {
      setDialogue("Gate’s open. Leave. Don’t let dawn learn your name.", "uneasy");
    }
  }

  // quick “first minute” guidance
  if(state.t < 8 && state.t > 2.5){
    // if player hasn't interacted yet
    if(!WORLD.objects.find(o=>o.id==="switchA").state && !WORLD.objects.find(o=>o.id==="switchB").state){
      // nothing, just let them explore
    }
  }
}

/* =========================================================
   OPTIONAL: auto-start hint
   ========================================================= */
setObjectiveText();
setDialogue("…", "watchful");

/* =========================================================
   PATCH: Canvas roundRect for older browsers
   ========================================================= */
if(!CanvasRenderingContext2D.prototype.roundRect){
  CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
    roundRect(this,x,y,w,h,r);
    return this;
  };
}

/* =========================================================
   INIT WORLD RULES
   ========================================================= */
applyWorldRules();

/* =========================================================
   CLICK-TO-START fallback (if user clicks canvas first)
   ========================================================= */
canvas.addEventListener("dblclick", ()=>{
  if(!state.started) startGame("normal");
});
</script>
</body>
</html>
